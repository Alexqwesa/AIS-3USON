#!/usr/bin/python3
# -------------------------------------------------------------------------------
# -*- coding: utf-8 -*-
# Name:        AIS 3USON classes with .ui files
# Purpose:
#
# Author:      Savin Alexander Viktorovich aka alexqwesa
# Created:     2020
# Copyright:   Savin Alexander Viktorovich aka alexqwesa
# Licence:     LGPL 3
# This software is licensed under the "LGPLv3" License as described in the "LICENSE" file,
# which should be included with this package. The terms are also available at
# http://www.gnu.org/licenses/lgpl-3.0.html
# -------------------------------------------------------------------------------

import calendar
import importlib
from typing import List

from qtpy.QtGui import QStandardItem
from qtpy.QtWidgets import QPushButton

from widgets.q_table_view import *


class stubQTableView(myQTableView):
    def __init__(self, parent=None):
        super().__init__(parent)
        # self.__class_prefix = "never_use_class_prefix"

    # def setObjectName(self, p_str):  # why not used?
    #     tname = p_str
    #     if "report_" in self.parent().parent().objectName():
    #         tname = "table_" + self.parent().parent().objectName()[len("report_"):]
    #     ret = super().setObjectName(tname)
    #     return ret

    def init_model(self):
        """Do nothing model filter chain will be inited by parent"""
        return True

    def init_model_filter(self):
        """Fix table name if not set"""
        if self.objectName() == "table" or self.objectName() == "":
            tname = "table_" + self.parent().parent().objectName()[len("report_"):]
            self.setObjectName(tname)
        # main
        ret = super().init_model_filter()
        return ret

    def init_model_explicit(self):
        if self.init_model_filter() and type(self.itemDelegate) != tsItemDelegate:
            #############################
            # set Delegate
            # ---------------------------
            self.inited = True
            self.setItemDelegate(tsItemDelegate(self))
        return True

    @Slot(bool)
    def setDirty(self, dirty=True):
        """set dirty for self and all parent  TODO: only allow revokeAll"""
        return super().setDirty(dirty)


class qcBaseWidgetClassLoader(QWidget):
    def __init__(self, parent=None, ui_name="qcStubWidget.ui"):
        """Constructor for qcQSelectPeriod"""
        super().__init__(parent)
        #############################
        # load new widgets
        # ---------------------------
        self.__shown = False
        self.ui_name = ui_name
        modules = list(sys.modules.keys())  # TODO: filter
        if "PyQt5" in modules:
            ui_module = importlib.import_module(
                "widgets_ui.autogenerated." + self.ui_name.replace(".ui", "") + "_pyqt5")
            # from ui_module import Ui_Form
        elif "PySide2" in modules:
            ui_module = importlib.import_module(
                "widgets_ui.autogenerated." + self.ui_name.replace(".ui", "") + "_pyside2")
        elif "PySide6" in modules:
            ui_module = importlib.import_module(
                "widgets_ui.autogenerated." + self.ui_name.replace(".ui", "") + "_pyside6")
        else:
            raise ImportError

        class MW(QWidget, ui_module.Ui_Form):
            def __init__(self, _parent=None):
                super().__init__(_parent)
                self.setupUi(_parent)

        self.ui: ui_module.Ui_Form = MW(self)
        # self.ui: Ui_Form = uic.loadUi(os.path.join(PROJECT_DIR, "widgets_ui", self.ui_name), self)
        #############################
        # block addWidget to layout
        # ---------------------------
        self.la_addItem = self.layout().addItem
        self.layout().addItem = lambda x: None
        self.la_addWidget = self.layout().addWidget
        self.layout().addWidget = lambda x: None

    def showEvent(self, event: QShowEvent):
        debug(self.objectName())
        if not self.__shown:
            self.remove_stub_widgets()
            # QTimer().singleShot(2000, self.remove_stub_widgets)  # hack TODO: rework it
        # la = self.layout()
        # debug(la)
        # debug(self.horizontalLayout)
        # if la:
        #     for i in range(la.count() - 1, -1, -1):
        #         try:
        #             # debug("%s ", la.itemAt(i).widget().objectName())
        #             # debug("%s ", la.itemAt(i).widget().parent().objectName())
        #             if la.itemAt(i).widget().objectName() != "tabs":
        #                 la.removeItem(la.itemAt(i))
        #         except AttributeError:
        #             la.removeItem(la.itemAt(i))
        return super().showEvent(event)

    def remove_stub_widgets(self):
        if "PyQt5" in sys.modules:
            wlist = self.findChildren(QWidget, None, Qt.FindDirectChildrenOnly)
        else:
            wlist = [w for w in self.findChildren(QWidget) if w.parent() == self]
        for w in wlist:  # TODO: use QDockWidget
            if w.objectName() != "qcFrame":
                w.hide()
                self.__shown = True
                for dw in w.findChildren(QWidget):
                    dw.deleteLater()
                w.deleteLater()


# @auto_reload_class_code(try_wrapper)
# @auto_reload_class_code(reloader)
class qcSelectReport(qcBaseWidgetClassLoader):
    """
    Class of several widgets to select date period
    """

    def __init__(self, parent=None):
        """Constructor for qcQSelectPeriod"""
        super().__init__(parent, ui_name="qcSelectReport.ui")
        #############################
        # set vars
        # ---------------------------
        ui = self.ui
        self.table: stubQTableView = ui.table
        self.period: qcSelectPeriod = ui.period
        self.btn_count: QPushButton = ui.btn_count
        self.btn_add_filter: QPushButton = ui.btn_add_filter
        #############################
        # init
        # ---------------------------
        self.btn_count.clicked.connect(self.show_report)

    @Slot(int, str)
    def set_first_filter_model(self, *args, **kwargs):
        return self.table.set_first_filter_model(*args, **kwargs)

    @Slot(str)
    def set_first_filter_str(self, *args, **kwargs):
        return self.table.set_first_filter_str(*args, **kwargs)

    @Slot(str)
    def set_second_filter_str(self, *args, **kwargs):
        return self.table.set_second_filter_str(*args, **kwargs)

    @Slot(int, str)
    def set_second_filter_model(self, *args, **kwargs):
        return self.table.set_second_filter_model(*args, **kwargs)

    def show_report(self):
        block_chain = []
        # block_chain.append(QSignalBlocker(self.table))
        # obj = selfself.table.objectName().table.model()
        # while obj:
        #     try:
        #         obj = obj.sourceModel()
        #         block_chain.append(QSignalBlocker(self.table))
        #     except:
        #         obj = None
        #############################
        # init tableView
        # ---------------------------
        self.table.init_model_explicit()
        #############################
        # re set Model TODO: rework it
        # ---------------------------
        mdl: tsSqlTableModel = self.table.model().super_model()
        mdl._meta_init = False
        mdl._init = False
        if mdl.call_template:
            filled_template = mdl.call_template.format(
                *self.period.date_period_as_str(SQL_DATE_FORMAT),
                mdl.sql_table())
            mdl.setCall(filled_template)
            debug(filled_template)
        elif mdl.filter():
            mdl.setFilter(
                "vdate between '{}' and '{}' ".format(
                    *self.period.date_period_as_str(SQL_DATE_FORMAT)))
        elif mdl.qry_template:
            filled_template = mdl.qry_template.format(
                *self.period.date_period_as_str(SQL_DATE_FORMAT),
                mdl.sql_table())
            mdl.setQuery(filled_template)
            debug(filled_template)
        else:
            error("can't detect report type")
            # self.table.model().select()
        return


class qcSelectPeriod(qcBaseWidgetClassLoader):
    """
    Class of several widgets to select date period
    """

    def __init__(self, parent=None):
        """Constructor for qcQSelectPeriod"""
        super().__init__(parent, ui_name="qcSelectPeriod.ui")
        #############################
        # set vars
        # ---------------------------
        ui = self.ui
        self.cbx_month = ui.cbx_month
        self.sp_year = ui.sp_year
        self.de_start: QDateEdit = ui.de_start
        self.de_stop: QDateEdit = ui.de_stop
        #############################
        # init
        # ---------------------------
        strs_for_cbox = self.tr("""Выберите месяц:, Январь, Февраль, Март,Апрель, Май, Июнь, """
                                """Июль, Август, Сентябрь, Октябрь, Ноябрь, Декабрь""", "comma is a separator")
        self.cbx_month.addItems([str(x) for x in strs_for_cbox.split(",")])
        item: QStandardItem = self.cbx_month.model().item(0)
        item.setFlags(item.flags() & (~(Qt.ItemIsSelectable | Qt.ItemIsEnabled)))
        self.cbx_month.setCurrentIndex(QDate().currentDate().month())
        self.sp_year.setValue(QDate().currentDate().year())
        #############################
        # sync fields
        # ---------------------------
        self.conv_date_to_month_year

    def conv_date_to_month_year(self):
        if self.cbx_month.currentIndex() == 0:
            return False
        self.de_start.setDate(QDate(self.sp_year.value(),
                                    self.cbx_month.currentIndex(),
                                    1))
        _, endday = calendar.monthrange(self.sp_year.value(), self.cbx_month.currentIndex())
        self.de_stop.setDate(QDate(self.sp_year.value(),
                                   int(self.cbx_month.currentIndex()),
                                   endday))

    @Slot(QDate)
    def on_de_stop_dateChanged(self, date: QDate):
        self.cbx_month.setCurrentIndex(date.month())
        self.sp_year.setValue(date.year())

    @Slot(int)
    def on_cbx_month_currentIndexChanged(self, ind: int):
        tabs: QTabWidget = self.ui.tabs
        if tabs.currentWidget().objectName() == "tab_month":
            self.conv_date_to_month_year()

    @Slot(int)
    def on_sp_year_valueChanged(self, year: int):
        # if self.ui.tabs.currentWidget().objectName() == "tab_month":
        self.conv_date_to_month_year()

    def date_period(self) -> Tuple[QDate, QDate]:
        return self.de_start.date(), self.de_stop.date()

    def date_period_as_str(self, qdate_format) -> List[str]:
        return [d.toString(qdate_format) for d in self.date_period()]
